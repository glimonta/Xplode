string_7_1 : "menor= "
string_7_2 : "\n"
string_7_3 : "mayor= "
string_7_4 : "\n"

#############################################################
#B1
#############################################################


#Este es el código generado por la linea 47 de la instrucción j := 0
j := 0
#############################################################
#B2
#############################################################


#Este es el código generado por la linea 49 de la instrucción while que inicia en begin_while_49_1 y termina en next_while_49_1
begin_while_49_1:
t1 < j 30
if t1 goto true_while_49_1
#############################################################
#B3
#############################################################


goto next_while_49_1
#############################################################
#B4
#############################################################


true_while_49_1:
read t2 2
t3 * j 4
a t3 []:= t2
#Este es el código generado por la linea 52 de la instrucción j := j + 1
t5 + j 1
j := t5
goto begin_while_49_1
#############################################################
#B5
#############################################################


next_while_49_1:
#Este es el código generado por la linea 56 de la instrucción respuesta := foldr(0, 30, menor, a)
#Este es el código generado por la linea 56 de la llamada a la función: foldr
#Aquí debería pasar el parámetro que es un arreglo pero me falta solucionar lo del dope vector
param_ref a  
param 30
param 1
param 4
param_ref menor  
param 30
param 0
t6 call foldr 4
respuesta := t6
#Este es el código generado por la linea 58 de la instrucción write
write string_7_1
write respuesta
write string_7_2
#Este es el código generado por la linea 60 de la instrucción respuesta := foldr(0, 30, mayor, a)
#Este es el código generado por la linea 60 de la llamada a la función: foldr
#Aquí debería pasar el parámetro que es un arreglo pero me falta solucionar lo del dope vector
param_ref a  
param 30
param 1
param 4
param_ref mayor  
param 30
param 0
t7 call foldr 4
respuesta := t7
#Este es el código generado por la linea 62 de la instrucción write
write string_7_3
write respuesta
write string_7_4
exit
#############################################################
#B6
#############################################################


#Definición de Función menor: linea 5
menor:
#Este es el código generado por la linea 7 de la instrucción if que termina en next_if_7_1
t8 < a b
ifnot t8 goto next_if_7_1
#############################################################
#B7
#############################################################


#Este es el código generado por la linea 9 de la instrucción return
return a
#############################################################
#B8
#############################################################


next_if_7_1:
#Este es el código generado por la linea 13 de la instrucción return
return b
#############################################################
#B9
#############################################################


#Definición de Función mayor: linea 17
mayor:
#Este es el código generado por la linea 19 de la instrucción if que termina en next_if_19_1
t9 > a b
ifnot t9 goto next_if_19_1
#############################################################
#B10
#############################################################


#Este es el código generado por la linea 21 de la instrucción return
return a
#############################################################
#B11
#############################################################


next_if_19_1:
#Este es el código generado por la linea 25 de la instrucción return
return b
#############################################################
#B12
#############################################################


#Definición de Función foldr: linea 29
foldr:
#Este es el código generado por la linea 31 de la instrucción if que termina en next_if_31_1
t10 == tam index
ifnot t10 goto next_if_31_1
#############################################################
#B13
#############################################################


#Este es el código generado por la linea 33 de la instrucción return
#Aquí va el acceso a un arreglo que es por referencia ==> dope vector
t11 - tam 1
t12 + bp 20
=* t13 t12
t14 * t11 t13
t15 :=[] arr t14
return t15
#############################################################
#B14
#############################################################


next_if_31_1:
#Este es el código generado por la linea 37 de la instrucción return
#Este es el código generado por la linea 37 de la llamada a la función: f
#Este es el código generado por la linea 37 de la llamada a la función: foldr
#Aquí debería pasar el parámetro que es un arreglo pero me falta solucionar lo del dope vector
param_ref arr  
param -1
param 1
param 4
param_ref f  
param tam
t16 + index 1
param t16
t17 call foldr 4
param t17
#Aquí va el acceso a un arreglo que es por referencia ==> dope vector
t18 + bp 20
=* t19 t18
t20 * index t19
t21 :=[] arr t20
param t21
t22 call f 2
return t22
